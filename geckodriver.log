1674577439539	geckodriver	INFO	Listening on 127.0.0.1:47901
1674577440491	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofileROTlpC"
Gtk-Message: 21:54:00.517: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674577441189	Marionette	INFO	Marionette enabled
1674577441193	Marionette	INFO	Listening on port 37653
ATTENTION: default value of option mesa_glthread overridden by environment.
Read port: 37653
1674577441353	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofileROTlpC/search.json.mozlz4", (void 0)))
JavaScript warning: https://api.fouanalytics.com/s/pp.js, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 7668 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
1674577520089	Marionette	INFO	Stopped listening on port 37653
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: chrome://remote/content/marionette/cert.sys.mjs, line 51: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsICertOverrideService.setDisableAllSecurityChecksAndLetAttackersInterceptMyData]
1674577526230	geckodriver	INFO	Listening on 127.0.0.1:35689
1674577527186	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofilexhj7Fz"
Gtk-Message: 21:55:27.221: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674577527888	Marionette	INFO	Marionette enabled
1674577527892	Marionette	INFO	Listening on port 46267
ATTENTION: default value of option mesa_glthread overridden by environment.
Read port: 46267
1674577528058	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofilexhj7Fz/search.json.mozlz4", (void 0)))
JavaScript warning: https://api.fouanalytics.com/s/pp.js, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
1674577544534	Marionette	INFO	Stopped listening on port 46267
JavaScript error: chrome://remote/content/marionette/cert.sys.mjs, line 51: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsICertOverrideService.setDisableAllSecurityChecksAndLetAttackersInterceptMyData]
1674581101747	geckodriver	INFO	Listening on 127.0.0.1:37867
1674581102705	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofileRz8cWM"
Gtk-Message: 22:55:02.728: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674581103392	Marionette	INFO	Marionette enabled
1674581103396	Marionette	INFO	Listening on port 36547
Read port: 36547
ATTENTION: default value of option mesa_glthread overridden by environment.
1674581103584	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofileRz8cWM/search.json.mozlz4", (void 0)))
JavaScript warning: https://api.fouanalytics.com/s/pp.js, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 4478 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 6281 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
1674585160694	geckodriver	INFO	Listening on 127.0.0.1:43715
1674585161620	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofileFPC7Zc"
Gtk-Message: 00:02:41.646: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674585162389	Marionette	INFO	Marionette enabled
1674585162393	Marionette	INFO	Listening on port 45579
Read port: 45579
ATTENTION: default value of option mesa_glthread overridden by environment.
1674585162586	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofileFPC7Zc/search.json.mozlz4", (void 0)))
1674585166052	Marionette	INFO	Stopped listening on port 36547
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript warning: https://api.fouanalytics.com/s/pp.js, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
1674585267137	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 3717 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 2766 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 3926 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
1674585318259	Marionette	INFO	Stopped listening on port 45579
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
1674585323441	geckodriver	INFO	Listening on 127.0.0.1:55209
1674585324376	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofileos1DNY"
Gtk-Message: 00:05:24.404: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674585325160	Marionette	INFO	Marionette enabled
1674585325164	Marionette	INFO	Listening on port 44631
Read port: 44631
ATTENTION: default value of option mesa_glthread overridden by environment.
1674585325358	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofileos1DNY/search.json.mozlz4", (void 0)))
console.error: Region.sys.mjs: "Error fetching region" (new Error("TIMEOUT", "resource://gre/modules/Region.sys.mjs", 764))
console.error: Region.sys.mjs: "Failed to fetch region" (new Error("TIMEOUT", "resource://gre/modules/Region.sys.mjs", 416))
JavaScript warning: https://api.fouanalytics.com/s/pp.js, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: https://imasdk.googleapis.com/formats/outstream/versioned/prod2/outstream_web_client_20230111_RC00/outstream.min.js, line 649: Error: lima_error_fetching_ad: Request timed out
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 6404 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.error: (new TypeError("lazy.AsyncShutdown.profileBeforeChange is undefined", "resource://services-settings/Database.jsm", 510))
1674585404677	geckodriver	INFO	Listening on 127.0.0.1:46371
1674585405614	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofilevQOrdE"
Gtk-Message: 00:06:45.644: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674585406418	Marionette	INFO	Marionette enabled
1674585406422	Marionette	INFO	Listening on port 46421
ATTENTION: default value of option mesa_glthread overridden by environment.
Read port: 46421
1674585406599	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofilevQOrdE/search.json.mozlz4", (void 0)))
1674585411955	Marionette	INFO	Stopped listening on port 46421
JavaScript error: chrome://remote/content/marionette/cert.sys.mjs, line 51: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsICertOverrideService.setDisableAllSecurityChecksAndLetAttackersInterceptMyData]
1674585429375	Marionette	INFO	Stopped listening on port 44631
1674585469950	geckodriver	INFO	Listening on 127.0.0.1:57641
1674585470913	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofileI90UK7"
Gtk-Message: 00:07:50.936: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674585471635	Marionette	INFO	Marionette enabled
1674585471639	Marionette	INFO	Listening on port 34575
ATTENTION: default value of option mesa_glthread overridden by environment.
Read port: 34575
1674585471842	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofileI90UK7/search.json.mozlz4", (void 0)))
JavaScript warning: https://api.fouanalytics.com/s/pp.js, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
1674585543232	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
1674585551801	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
1674585572246	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
1674585603255	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
1674585612655	Marionette	INFO	Stopped listening on port 34575
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: chrome://remote/content/marionette/cert.sys.mjs, line 51: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsICertOverrideService.setDisableAllSecurityChecksAndLetAttackersInterceptMyData]
1674585615392	geckodriver	INFO	Listening on 127.0.0.1:35233
1674585616344	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofileP6KN9D"
Gtk-Message: 00:10:16.380: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674585617041	Marionette	INFO	Marionette enabled
1674585617045	Marionette	INFO	Listening on port 43215
Read port: 43215
ATTENTION: default value of option mesa_glthread overridden by environment.
1674585617246	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofileP6KN9D/search.json.mozlz4", (void 0)))
JavaScript warning: https://api.fouanalytics.com/s/pp.js, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5015 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 2006 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
1674585716799	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5973 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
1674585722793	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
1674585801503	Marionette	INFO	Stopped listening on port 43215
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
1674585822260	geckodriver	INFO	Listening on 127.0.0.1:33769
1674585823197	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofileuYWuvN"
Gtk-Message: 00:13:43.238: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674585823880	Marionette	INFO	Marionette enabled
1674585823883	Marionette	INFO	Listening on port 42103
Read port: 42103
ATTENTION: default value of option mesa_glthread overridden by environment.
1674585824046	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofileuYWuvN/search.json.mozlz4", (void 0)))
JavaScript warning: https://api.fouanalytics.com/s/pp.js, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
1674585841062	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 6480 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 1990 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 3219 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.error: (new TypeError("lazy.AsyncShutdown.profileBeforeChange is undefined", "resource://services-settings/Database.jsm", 510))
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574857/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574857/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574876/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574876/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574862/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574862/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574886/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574886/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574858/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574858/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574878/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574878/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574863/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574863/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574888/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574888/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574859/thread1, type attach failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:571:32\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574859/thread1, type attach failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:571:32\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574880/thread1, type attach failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:571:32\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574880/thread1, type attach failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:571:32\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574864/thread1, type attach failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:571:32\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574864/thread1, type attach failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:571:32\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574890/thread1, type attach failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:571:32\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574890/thread1, type attach failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:571:32\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 2988 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.error: "Error while calling actor 'domwalker's method 'getEmbedderElement'" "Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode]"
console.error: ({})
console.error: "Error while calling actor 'domwalker's method 'getEmbedderElement'" "Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode]"
console.error: ({})
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574897/domwalker22, type watchRootNode failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nmodule.exports@resource://devtools/shared/commands/resource/legacy-listeners/root-node.js:60:31\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Failed to start [root-node] legacy listener for target server0.conn0.windowGlobal55834574918/windowGlobalTarget2" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574897/domwalker22, type getEmbedderElement failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nreparentRemoteFrame@resource://devtools/client/fronts/walker.js:409:26\n", "resource://devtools/shared/protocol/Front.js", 106))
console.warn: "Error while destroying front:" "inspector" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574897/domwalker22, type getEmbedderElement failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nreparentRemoteFrame@resource://devtools/client/fronts/walker.js:409:26\n", "resource://devtools/shared/protocol/Front.js", 106))
console.warn: "Error while destroying front:" "inspector" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442450945/domwalker23 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442450945/domwalker23 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.warn: "Error while destroying front:" "inspector" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442450945/domwalker23 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442450945/domwalker23 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.warn: "Error while destroying front:" "inspector" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442450945/domwalker23 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442450945/domwalker23 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.warn: "Error while destroying front:" "inspector" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442450945/domwalker23 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442450945/domwalker23 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574933/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal55834574933/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
console.error: "Error while calling actor 'domwalker's method 'getEmbedderElement'" "Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode]"
console.error: ({})
console.warn: "Error while destroying front:" "inspector" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442450945/domwalker23 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
SourceActor threw an exception: [Exception... "Failed to open input source 'chrome://global/content/neterror/aboutNetErrorCodes.js'"  nsresult: "0x805303f4 (<unknown>)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: mainThreadFetch/< :: line 676"  data: yes]
Stack: mainThreadFetch/<@resource://devtools/shared/DevToolsUtils.js:676:15
mainThreadFetch@resource://devtools/shared/DevToolsUtils.js:517:10
_fetchURLContents@resource://devtools/server/actors/utils/sources-manager.js:446:22
urlContents@resource://devtools/server/actors/utils/sources-manager.js:410:17
_resurrectSource@resource://devtools/server/actors/thread.js:2154:35
addAllSources@resource://devtools/server/actors/thread.js:1486:14
watch@resource://devtools/server/actors/resources/sources.js:78:17
watchResources@resource://devtools/server/actors/resources/index.js:302:19
addSessionDataEntry@resource://devtools/server/actors/targets/session-data-processors/resources.js:11:21
addSessionDataEntry@resource://devtools/server/actors/targets/target-actor-mixin.js:46:25
_addSessionDataEntry@resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.sys.mjs:530:24
receiveMessage@resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.sys.mjs:439:21
Line: 676, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 676: Failed to open input source 'chrome://global/content/neterror/aboutNetErrorCodes.js'
JavaScript error: resource://devtools/server/actors/utils/sources-manager.js, line 432: TypeError: channel is null
JavaScript error: resource://devtools/server/actors/utils/sources-manager.js, line 432: TypeError: channel is null
JavaScript error: resource://devtools/server/actors/utils/sources-manager.js, line 432: TypeError: channel is null
JavaScript error: resource://devtools/server/actors/utils/sources-manager.js, line 432: TypeError: channel is null
JavaScript error: resource://devtools/server/actors/utils/sources-manager.js, line 432: TypeError: channel is null
JavaScript error: resource://devtools/server/actors/utils/sources-manager.js, line 432: TypeError: channel is null
JavaScript error: resource://devtools/server/actors/utils/sources-manager.js, line 432: TypeError: channel is null
JavaScript error: resource://devtools/server/actors/utils/sources-manager.js, line 432: TypeError: channel is null
JavaScript error: resource://devtools/server/actors/utils/sources-manager.js, line 432: TypeError: channel is null
console.warn: "Error while destroying front:" "inspector" (new Error("Connection closed, pending request to server0.conn0.windowGlobal8589934614/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5153 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.warn: "Listener for event 'frame' did not return a promise."
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 568"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:568:34
onStopRequest@resource://gre/modules/NetUtil.jsm:126:18
Line: 568, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 568: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5030 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: resource://devtools/client/framework/toolbox.js, line 3513: TypeError: data.frameData.id is null
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 7023 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1664"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1664:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:779:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:348:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1664, column: 0
console.error: ({})
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1664"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1664:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:779:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:348:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1664, column: 0
console.error: ({})
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 422: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 422: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 422: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 422: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1664"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1664:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:779:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:348:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1664, column: 0
console.error: ({})
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
console.error: "Error when destroying StyleSheet manager for" ({conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}}, actorID:"server0.conn0.windowGlobal60129542145/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onscrollend() {
    [native code]
}, set onscrollend() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, isPrivate:false, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:7, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false, supportedTargets:{frame:true, process:true, worker:true}, supportedResources:{'console-message':true, 'css-change':true, 'css-message':true, 'document-event':true, Cache:true, cookies:true, 'error-message':true, 'indexed-db':true, 'local-storage':true, 'session-storage':true, 'platform-message':true, 'network-event':true, 'network-event-stacktrace':true, reflow:true, stylesheet:true, source:true, 'thread-state':true, 'server-sent-event':true, websocket:true}}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn0.windowGlobal60129542145/consoleActor3", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn0.windowGlobal60129542145/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn0.windowGlobal60129542145/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn0.windowGlobal60129542145/storageActor6", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn0.windowGlobal60129542145/memoryActor7", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn0.windowGlobal60129542145/reflowActor8", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn0.windowGlobal60129542145/cssPropertiesActor9", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn0.windowGlobal60129542145/animationsActor10", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn0.windowGlobal60129542145/responsiveActor11", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn0.windowGlobal60129542145/webExtensionInspectedWindowActor12", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn0.windowGlobal60129542145/accessibilityActor13", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn0.windowGlobal60129542145/changesActor14", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn0.windowGlobal60129542145/webSocketActor15", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn0.windowGlobal60129542145/eventSourceActor16", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn0.windowGlobal60129542145/manifestActor17", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn0.windowGlobal60129542145/networkContentActor18", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn0.windowGlobal60129542145/screenshotContentActor19", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}}, actorID:"server0.conn0.windowGlobal60129542145/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onscrollend() {
    [native code]
}, set onscrollend() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}}, actorID:"server0.conn0.windowGlobal60129542145/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onscrollend() {
    [native code]
}, set onscrollend() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542145/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542145", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, customFormatters:false, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 916))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1712: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.warn: "Listener for event 'frame' did not return a promise."
console.error: "Error when destroying StyleSheet manager for" ({conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}}, actorID:"server0.conn0.windowGlobal60129542146/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onscrollend() {
    [native code]
}, set onscrollend() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, isPrivate:false, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:7, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false, supportedTargets:{frame:true, process:true, worker:true}, supportedResources:{'console-message':true, 'css-change':true, 'css-message':true, 'document-event':true, Cache:true, cookies:true, 'error-message':true, 'indexed-db':true, 'local-storage':true, 'session-storage':true, 'platform-message':true, 'network-event':true, 'network-event-stacktrace':true, reflow:true, stylesheet:true, source:true, 'thread-state':true, 'server-sent-event':true, websocket:true}}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn0.windowGlobal60129542146/consoleActor3", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn0.windowGlobal60129542146/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn0.windowGlobal60129542146/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn0.windowGlobal60129542146/storageActor6", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn0.windowGlobal60129542146/memoryActor7", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn0.windowGlobal60129542146/reflowActor8", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn0.windowGlobal60129542146/cssPropertiesActor9", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn0.windowGlobal60129542146/animationsActor10", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn0.windowGlobal60129542146/responsiveActor11", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn0.windowGlobal60129542146/webExtensionInspectedWindowActor12", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn0.windowGlobal60129542146/accessibilityActor13", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn0.windowGlobal60129542146/changesActor14", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn0.windowGlobal60129542146/webSocketActor15", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn0.windowGlobal60129542146/eventSourceActor16", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn0.windowGlobal60129542146/manifestActor17", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn0.windowGlobal60129542146/networkContentActor18", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn0.windowGlobal60129542146/screenshotContentActor19", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}}, actorID:"server0.conn0.windowGlobal60129542146/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onscrollend() {
    [native code]
}, set onscrollend() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}}, actorID:"server0.conn0.windowGlobal60129542146/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onscrollend() {
    [native code]
}, set onscrollend() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542146/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542146", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, customFormatters:false, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 916))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1712: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error when destroying StyleSheet manager for" ({conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}}, actorID:"server0.conn0.windowGlobal60129542147/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onscrollend() {
    [native code]
}, set onscrollend() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, isPrivate:false, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:7, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false, supportedTargets:{frame:true, process:true, worker:true}, supportedResources:{'console-message':true, 'css-change':true, 'css-message':true, 'document-event':true, Cache:true, cookies:true, 'error-message':true, 'indexed-db':true, 'local-storage':true, 'session-storage':true, 'platform-message':true, 'network-event':true, 'network-event-stacktrace':true, reflow:true, stylesheet:true, source:true, 'thread-state':true, 'server-sent-event':true, websocket:true}}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn0.windowGlobal60129542147/consoleActor3", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn0.windowGlobal60129542147/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn0.windowGlobal60129542147/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn0.windowGlobal60129542147/storageActor6", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn0.windowGlobal60129542147/memoryActor7", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn0.windowGlobal60129542147/reflowActor8", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn0.windowGlobal60129542147/cssPropertiesActor9", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn0.windowGlobal60129542147/animationsActor10", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn0.windowGlobal60129542147/responsiveActor11", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn0.windowGlobal60129542147/webExtensionInspectedWindowActor12", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn0.windowGlobal60129542147/accessibilityActor13", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn0.windowGlobal60129542147/changesActor14", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn0.windowGlobal60129542147/webSocketActor15", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn0.windowGlobal60129542147/eventSourceActor16", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn0.windowGlobal60129542147/manifestActor17", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn0.windowGlobal60129542147/networkContentActor18", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn0.windowGlobal60129542147/screenshotContentActor19", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}}, actorID:"server0.conn0.windowGlobal60129542147/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onscrollend() {
    [native code]
}, set onscrollend() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}}, actorID:"server0.conn0.windowGlobal60129542147/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onscrollend() {
    [native code]
}, set onscrollend() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn0.windowGlobal60129542147/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal60129542147", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, customFormatters:false, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 916))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1712: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 376))
InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment: sendPacket@resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.sys.mjs:376:10
send@resource://devtools/shared/transport/js-window-actor-transport.js:58:25
send@resource://devtools/server/devtools-server-connection.js:103:20
_sendEvent@resource://devtools/shared/protocol/Actor.js:72:15
initialize/<@resource://devtools/shared/protocol/Actor.js:46:16
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
notifyResources@resource://devtools/server/actors/targets/target-actor-mixin.js:82:12
onReflows@resource://devtools/server/actors/resources/reflow.js:40:18
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
_startEventLoop@resource://devtools/server/actors/reflow.js:313:12
notify@resource://gre/modules/Timer.sys.mjs:49:17

console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 376))
InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment: sendPacket@resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.sys.mjs:376:10
send@resource://devtools/shared/transport/js-window-actor-transport.js:58:25
send@resource://devtools/server/devtools-server-connection.js:103:20
_sendEvent@resource://devtools/shared/protocol/Actor.js:72:15
initialize/<@resource://devtools/shared/protocol/Actor.js:46:16
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
notifyResources@resource://devtools/server/actors/targets/target-actor-mixin.js:82:12
onReflows@resource://devtools/server/actors/resources/reflow.js:40:18
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
_startEventLoop@resource://devtools/server/actors/reflow.js:313:12
notify@resource://gre/modules/Timer.sys.mjs:49:17

console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 376))
InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment: sendPacket@resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.sys.mjs:376:10
send@resource://devtools/shared/transport/js-window-actor-transport.js:58:25
send@resource://devtools/server/devtools-server-connection.js:103:20
_sendEvent@resource://devtools/shared/protocol/Actor.js:72:15
initialize/<@resource://devtools/shared/protocol/Actor.js:46:16
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
notifyResources@resource://devtools/server/actors/targets/target-actor-mixin.js:82:12
onReflows@resource://devtools/server/actors/resources/reflow.js:40:18
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
_startEventLoop@resource://devtools/server/actors/reflow.js:313:12
notify@resource://gre/modules/Timer.sys.mjs:49:17

Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
JavaScript error: resource://devtools/client/jsonview/Sniffer.sys.mjs, line 53: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIHttpChannel.contentType]
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 4737 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 3457 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Error while destroying front:" "inspector" (new Error("Connection closed, pending request to server0.conn0.windowGlobal8589934633/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Connection closed, pending request to server0.conn0.windowGlobal8589934633/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Error while calling actor 'domwalker's method 'getEmbedderElement'" "Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode]"
console.error: ({})
JavaScript error: resource://devtools/shared/protocol/Front.js, line 106: Error: Connection closed, pending request to server0.conn0.windowGlobal8589934633/inspectorActor4, type getWalker failed

Request stack:
request@resource://devtools/shared/protocol/Front.js:300:14
generateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19
_getWalker@resource://devtools/client/fronts/inspector.js:91:30
initialize@resource://devtools/client/fronts/inspector.js:80:12

console.warn: "Error while destroying front:" "inspector" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442451261/domwalker26 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442451261/domwalker26 (resource://devtools/server/actors/inspector/document-walker.js:77:0)", "resource://devtools/shared/protocol/Front.js", 383))
JavaScript error: resource://devtools/shared/protocol/Front.js, line 383: Error: Protocol error (NS_ERROR_FAILURE): Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [inIDeepTreeWalker.currentNode] from: server0.conn0.windowGlobal6442451261/domwalker26 (resource://devtools/server/actors/inspector/document-walker.js:77:0)
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 6412 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Error while destroying front:" "inspector" (new Error("Connection closed, pending request to server0.conn0.windowGlobal8589934636/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Connection closed, pending request to server0.conn0.windowGlobal8589934636/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/shared/protocol/Front.js, line 106: Error: Connection closed, pending request to server0.conn0.windowGlobal8589934636/inspectorActor4, type getWalker failed

Request stack:
request@resource://devtools/shared/protocol/Front.js:300:14
generateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19
_getWalker@resource://devtools/client/fronts/inspector.js:91:30
initialize@resource://devtools/client/fronts/inspector.js:80:12

console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.error: "Unable to find target with innerWindowId:6442451215"
console.error: "Unable to find target with innerWindowId:6442451215"
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
#onRequestHeader@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:762:29
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:632:28
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
Handler function threw an exception: TypeError: httpActivity.owner is null
Stack: #onResponseHeader@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:1046:5
#dispatchActivity@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:553:31
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:662:29
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 1046, column: 5
console.error: (new TypeError("httpActivity.owner is null", "resource://devtools/shared/network-observer/NetworkObserver.sys.mjs", 1046))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:336:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Error while destroying front:" "inspector" (new Error("Connection closed, pending request to server0.conn0.windowGlobal64424509441/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 1855 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Error while destroying front:" "inspector" (new Error("Connection closed, pending request to server0.conn0.windowGlobal8589934640/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Connection closed, pending request to server0.conn0.windowGlobal8589934640/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/shared/protocol/Front.js, line 106: Error: Connection closed, pending request to server0.conn0.windowGlobal8589934640/inspectorActor4, type getWalker failed

Request stack:
request@resource://devtools/shared/protocol/Front.js:300:14
generateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19
_getWalker@resource://devtools/client/fronts/inspector.js:91:30
initialize@resource://devtools/client/fronts/inspector.js:80:12

console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Async method failed in safeAsyncMethod" (new Error("Connection closed, pending request to server0.conn0.windowGlobal6442451249/layout31, type getGrids failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\ngetAllGrids@resource://devtools/client/fronts/layout.js:173:17\nexports.safeAsyncMethod/<@resource://devtools/shared/async-utils.js:61:25\ngetGrids@resource://devtools/client/inspector/grids/grid-inspector.js:452:35\n", "resource://devtools/shared/protocol/Front.js", 106))
console.warn: "Async method failed in safeAsyncMethod" (new Error("Connection closed, pending request to server0.conn0.windowGlobal6442451301/layout28, type getGrids failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\ngetAllGrids@resource://devtools/client/fronts/layout.js:173:17\nexports.safeAsyncMethod/<@resource://devtools/shared/async-utils.js:61:25\ngetGrids@resource://devtools/client/inspector/grids/grid-inspector.js:452:35\n", "resource://devtools/shared/protocol/Front.js", 106))
Handler function threw an exception: TypeError: browsingContext.currentWindowGlobal is null
Stack: isChannelFromSystemPrincipal@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:91:1
createNetworkEvent@resource://devtools/shared/network-observer/NetworkUtils.sys.mjs:179:33
#createNetworkEvent@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:712:37
@resource://devtools/shared/network-observer/NetworkObserver.sys.mjs:343:35
makeInfallible/<@resource://devtools/shared/DevToolsInfaillibleUtils.sys.mjs:43:22
Line: 91, column: 1
console.error: (new TypeError("browsingContext.currentWindowGlobal is null", "resource://devtools/shared/network-observer/NetworkUtils.sys.mjs", 91))
console.warn: "Async method failed in safeAsyncMethod" (new Error("Connection closed, pending request to server0.conn0.windowGlobal6442451261/layout29, type getGrids failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\ngetAllGrids@resource://devtools/client/fronts/layout.js:173:17\nexports.safeAsyncMethod/<@resource://devtools/shared/async-utils.js:61:25\ngetGrids@resource://devtools/client/inspector/grids/grid-inspector.js:452:35\n", "resource://devtools/shared/protocol/Front.js", 106))
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 6837 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Error while destroying front:" "inspector" (new Error("Connection closed, pending request to server0.conn0.windowGlobal8589934645/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Connection closed, pending request to server0.conn0.windowGlobal8589934645/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\n_getWalker@resource://devtools/client/fronts/inspector.js:91:30\ninitialize@resource://devtools/client/fronts/inspector.js:80:12\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/shared/protocol/Front.js, line 106: Error: Connection closed, pending request to server0.conn0.windowGlobal8589934645/inspectorActor4, type getWalker failed

Request stack:
request@resource://devtools/shared/protocol/Front.js:300:14
generateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19
_getWalker@resource://devtools/client/fronts/inspector.js:91:30
initialize@resource://devtools/client/fronts/inspector.js:80:12

console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5469 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.warn: "Listener for event 'frame' did not return a promise."
1674585939765	geckodriver	INFO	Listening on 127.0.0.1:32817
1674585940712	mozrunner::runner	INFO	Running command: "/snap/firefox/current/firefox.launcher" "--marionette" "-no-remote" "-profile" "/tmp/rust_mozprofilepQnUoJ"
Gtk-Message: 00:15:40.754: Not loading module "atk-bridge": The functionality is provided by GTK natively. Please try to not load it.
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal38654705671/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
console.warn: "Listener for event 'frame' did not return a promise."
ATTENTION: default value of option mesa_glthread overridden by environment.
ATTENTION: default value of option mesa_glthread overridden by environment.
amdgpu: os_same_file_description couldn't determine if two DRM fds reference the same file description.
If they do, bad things may happen!
1674585941507	Marionette	INFO	Marionette enabled
1674585941511	Marionette	INFO	Listening on port 39217
Read port: 39217
ATTENTION: default value of option mesa_glthread overridden by environment.
1674585941675	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at /tmp/rust_mozprofilepQnUoJ/search.json.mozlz4", (void 0)))
JavaScript warning: https://api.fouanalytics.com/s/pp.js, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 572: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1674585945915	Marionette	INFO	Stopped listening on port 42103
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 7657 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5637 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: uncaught exception: 7
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 7589 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 4969 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
1674586038288	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
1674586044286	Marionette	WARN	Ignoring event 'pageshow' because document has an invalid readyState of 'uninitialized'.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5305 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5527 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 6453 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5626 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
JavaScript warning: https://pagead2.googlesyndication.com/bg/OU_aD-3-G2pcaJqwlUagl315JVS_daCE4k47Wxj7Xso.js line 2 > eval line 5943 > eval line 1 > eval line 1 > eval, line 1: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
JavaScript error: , line 0: TypeError: NetworkError when attempting to fetch resource.
